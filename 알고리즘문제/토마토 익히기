문제: 토마토 익히기
설명
n x m 크기의 상자가 주어집니다. 상자 안에는 익은 토마토, 익지 않은 토마토, 그리고 빈 칸이 있으며, 토마토는 하루가 지나면 인접한 상하좌우 토마토에게 영향을 줘서 익게 만듭니다. 상자 안의 모든 토마토가 익는 데 걸리는 최소 날짜를 구하세요. 만약 모든 토마토가 익지 못하는 상황이라면 -1을 반환합니다.

익은 토마토: 1
익지 않은 토마토: 0
빈 칸: -1
입력 형식

첫째 줄: 상자의 크기 n, m (1 ≤ m, n ≤ 1,000)
둘째 줄부터: 상자의 상태를 나타내는 m x n 배열
출력 형식

모든 토마토가 익을 수 있다면 최소 날짜를 출력하고, 아니면 -1을 출력합니다.
입력 예시
6 4
0 0 -1 0 0 0
0 0 1 0 -1 0
0 0 -1 0 0 0
0 0 0 0 -1 1


4

풀이 코드 (Python)
이 문제는 BFS로 풀 수 있습니다. BFS를 이용하면 토마토가 익어가는 과정을 탐색하며 날짜를 계산할 수 있습니다.
from collections import deque

def tomato_ripening(m, n, box):
    # 이동 방향 (상, 하, 좌, 우)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    queue = deque()
    # 초기 상태에서 익은 토마토 위치를 큐에 추가
    for i in range(n):
        for j in range(m):
            if box[i][j] == 1:
                queue.append((i, j, 0))  # (x, y, day)

    max_day = 0  # 걸리는 최소 일수
    
    # BFS 실행
    while queue:
        x, y, day = queue.popleft()
        max_day = max(max_day, day)  # 날짜 갱신
        
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            # 범위 내에 있고 익지 않은 토마토인 경우
            if 0 <= nx < n and 0 <= ny < m and box[nx][ny] == 0:
                box[nx][ny] = 1  # 익은 상태로 변경
                queue.append((nx, ny, day + 1))

    # 모든 토마토가 익었는지 확인
    for row in box:
        if 0 in row:  # 익지 않은 토마토가 있는 경우
            return -1
    return max_day

# 테스트 예제
m, n = 6, 4
box = [
    [0, 0, -1, 0, 0, 0],
    [0, 0, 1, 0, -1, 0],
    [0, 0, -1, 0, 0, 0],
    [

풀이 설명
  큐 초기화: 익은 토마토의 위치를 모두 queue에 추가합니다.
  BFS 탐색: queue에서 토마토를 꺼내 상하좌우로 익히면서 날짜를 갱신합니다.
  날짜 계산: 각 토마토가 익을 때마다 day + 1로 날짜를 기록해 최종적으로 max_day에 최댓값을 저장합니다.
  익지 않은 토마토 확인: 모든 탐색 후 0이 남아있으면 -1을 반환하고, 그렇지 않다면 max_day를 반환합니다.
이 코드를 통해 최소 일수를 계산하고, 만약 모든 토마토를 익힐 수 없으면 -1을 반환할 수 있습니다.
