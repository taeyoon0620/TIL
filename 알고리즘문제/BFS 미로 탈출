문제: 미로 탈출
설명
n x m 크기의 미로가 주어집니다. 미로는 1과 0으로 이루어져 있으며, 1은 이동할 수 있는 길, 0은 벽을 의미합니다. 당신은 (0, 0) 위치에서 시작해서 (n-1, m-1) 위치까지 이동해야 합니다. 최소 몇 번의 이동으로 탈출할 수 있는지 구하세요. 이동할 때는 상하좌우 인접한 칸으로만 이동할 수 있습니다.

입력 예시

n, m = 5, 6
maze = [
    [1, 0, 1, 0, 1, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0],
    [1, 1, 1, 0, 1, 1],
    [1, 0, 1, 1, 1, 1]
]


10

풀이 코드 (Python)

from collections import deque

def escape_maze(n, m, maze):
    # 이동 방향 (상, 하, 좌, 우)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
    # BFS를 위한 큐 초기화 (시작점과 이동 거리 함께 저장)
    queue = deque([(0, 0, 1)])  # (x, y, distance)
    visited = set((0, 0))

    while queue:
        x, y, dist = queue.popleft()

        # 목적지에 도달하면 거리 반환
        if x == n - 1 and y == m - 1:
            return dist

        # 상하좌우로 이동
        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            # 미로 범위 내에 있고 이동할 수 있는 길이며, 방문하지 않은 경우
            if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 1 and (nx, ny) not in visited:
                visited.add((nx, ny))
                queue.append((nx, ny, dist + 1))

    # 도달할 수 없는 경우
    return -1

# 테스트 예제
n, m = 5, 6
maze = [
    [1, 0, 1, 0, 1, 0],
    [1, 1, 1, 1, 1, 0],
    [0, 0, 0, 0, 1, 0],
    [1, 1, 1, 0, 1, 1],
    [1, 0, 1, 1, 1, 1]
]

print(escape_maze(n, m, maze))  # 출력: 10

풀이 설명
  큐 초기화: 시작점 (0, 0)에서 시작하고, BFS 큐에 (x, y, distance) 형식으로 저장합니다.
  BFS 탐색: 큐에서 노드를 꺼내고, 상하좌우로 이동 가능한 위치를 계산합니다.
  방문 처리와 거리 누적: 이동할 수 있는 길이고 아직 방문하지 않았다면, 해당 좌표를 큐에 추가하면서 거리를 1씩 증가시킵니다.
  목적지 도달 시 종료: (n-1, m-1)에 도달한 경우 현재까지 이동한 거리를 반환합니다.
  도달 불가 시: 탈출할 수 없으면 -1을 반환합니다.
이 코드로 미로의 최소 탈출 거리를 계산할 수 있습니다.
