문제 설명:
정수 배열 nums와 정수 target이 주어졌을 때, 배열에서 두 수를 골라 더했을 때 그 합이 target이 되는 두 수의 인덱스를 찾으세요. 각 입력에 정확히 하나의 정답이 있다고 가정하며, 같은 원소를 두 번 사용할 수 없습니다.

입력:

정수 배열 nums (배열의 길이는 최소 2 이상)
정수 target
출력:

두 수의 인덱스를 담은 리스트 [index1, index2] (index1 < index2)

예시 1
입력: nums = [2, 7, 11, 15], target = 9
출력: [0, 1]

설명: nums[0] + nums[1] = 2 + 7 = 9이므로, 결과는 [0, 1]입니다.

예시 2
입력: nums = [3, 2, 4], target = 6
출력: [1, 2]

설명: nums[1] + nums[2] = 2 + 4 = 6이므로, 결과는 [1, 2]입니다.

풀이
브루트포스 방식(직접 비교):

배열 내 모든 쌍을 탐색하여 두 수의 합이 target이 되는지 확인하는 방식입니다.
하지만 시간 복잡도가 **O(n²)**로, 효율적인 방법은 아닙니다.
해시맵을 이용한 효율적 풀이:

각 숫자를 배열을 탐색하면서, 그 숫자와 target에서 그 숫자를 뺀 값이 이전에 등장했는지 확인합니다.
이를 위해 해시맵(딕셔너리)을 사용하여 각 숫자의 인덱스를 저장합니다.
현재 숫자를 처리하기 전에 해시맵에서 target - 현재 숫자를 찾고, 있으면 그 두 수의 인덱스를 반환합니다.

코드 구현
def twoSum(nums, target):
    hashmap = {}  # 숫자와 그 숫자의 인덱스를 저장할 딕셔너리
    for i, num in enumerate(nums):
        complement = target - num  # target에서 현재 숫자를 뺀 값
        if complement in hashmap:
            return [hashmap[complement], i]  # 두 수의 인덱스 반환
        hashmap[num] = i  # 현재 숫자와 그 인덱스를 해시맵에 저장

동작 설명:
nums 배열을 한 번 순회하면서 현재 숫자와 target에서 그 숫자를 뺀 값을 구합니다.
그 값이 해시맵에 존재한다면, 그 값은 이미 이전에 등장한 값이므로 두 숫자의 인덱스를 반환합니다.
그렇지 않다면, 현재 숫자와 인덱스를 해시맵에 저장합니다.
시간 복잡도:
배열을 한 번 순회하므로 **O(n)**의 시간 복잡도를 가집니다. n은 nums 배열의 길이입니다.
해시맵에서 값을 찾고 추가하는 작업은 평균적으로 **O(1)**입니다.


문제: "두 수의 합"
문제 설명:
정수 배열 nums와 정수 target이 주어졌을 때, 배열에서 두 수를 골라 더했을 때 그 합이 target이 되는 두 수의 인덱스를 찾으세요. 각 입력에 정확히 하나의 정답이 있다고 가정하며, 같은 원소를 두 번 사용할 수 없습니다.

입력:

정수 배열 nums (배열의 길이는 최소 2 이상)
정수 target
출력:

두 수의 인덱스를 담은 리스트 [index1, index2] (index1 < index2)
예시 1:
less
코드 복사
입력: nums = [2, 7, 11, 15], target = 9
출력: [0, 1]

설명: nums[0] + nums[1] = 2 + 7 = 9이므로, 결과는 [0, 1]입니다.
예시 2:
less
코드 복사
입력: nums = [3, 2, 4], target = 6
출력: [1, 2]

설명: nums[1] + nums[2] = 2 + 4 = 6이므로, 결과는 [1, 2]입니다.
풀이
브루트포스 방식(직접 비교):

배열 내 모든 쌍을 탐색하여 두 수의 합이 target이 되는지 확인하는 방식입니다.
하지만 시간 복잡도가 **O(n²)**로, 효율적인 방법은 아닙니다.
해시맵을 이용한 효율적 풀이:

각 숫자를 배열을 탐색하면서, 그 숫자와 target에서 그 숫자를 뺀 값이 이전에 등장했는지 확인합니다.
이를 위해 해시맵(딕셔너리)을 사용하여 각 숫자의 인덱스를 저장합니다.
현재 숫자를 처리하기 전에 해시맵에서 target - 현재 숫자를 찾고, 있으면 그 두 수의 인덱스를 반환합니다.
코드 구현:
python
코드 복사
def twoSum(nums, target):
    hashmap = {}  # 숫자와 그 숫자의 인덱스를 저장할 딕셔너리
    for i, num in enumerate(nums):
        complement = target - num  # target에서 현재 숫자를 뺀 값
        if complement in hashmap:
            return [hashmap[complement], i]  # 두 수의 인덱스 반환
        hashmap[num] = i  # 현재 숫자와 그 인덱스를 해시맵에 저장
동작 설명:
nums 배열을 한 번 순회하면서 현재 숫자와 target에서 그 숫자를 뺀 값을 구합니다.
그 값이 해시맵에 존재한다면, 그 값은 이미 이전에 등장한 값이므로 두 숫자의 인덱스를 반환합니다.
그렇지 않다면, 현재 숫자와 인덱스를 해시맵에 저장합니다.
시간 복잡도:
배열을 한 번 순회하므로 **O(n)**의 시간 복잡도를 가집니다. n은 nums 배열의 길이입니다.
해시맵에서 값을 찾고 추가하는 작업은 평균적으로 **O(1)**입니다.

예시 실행
# 예시 1
nums = [2, 7, 11, 15]
target = 9
print(twoSum(nums, target))  # 출력: [0, 1]

# 예시 2
nums = [3, 2, 4]
target = 6
print(twoSum(nums, target))  # 출력: [1, 2]
이 코드에서는 배열 내에서 두 수를 찾아 그 인덱스를 반환하는 효율적인 방법을 사용하고 있습니다.







