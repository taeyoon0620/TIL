  JIT(Just-In-Time) 컴파일러는 Java Virtual Machine(JVM)에서 바이트코드를 실행 시 **런타임에 기계어(네이티브 코드)**로 변환하는 컴파일러입니다. 
  JIT 컴파일러는 성능을 최적화하기 위해 자주 실행되는 코드를 네이티브 코드로 컴파일하여, 해당 코드를 재실행할 때 빠르게 실행될 수 있도록 돕습니다.

  JIT 컴파일러의 동작 원리
  Java 바이트코드 실행: Java 프로그램이 실행되면, 바이트코드는 처음에 인터프리터에 의해 한 줄씩 실행됩니다.
  핫스팟(Hotspot) 탐지: JIT 컴파일러는 핫스팟이라고 불리는 자주 호출되는 메서드나 루프 같은 빈번하게 실행되는 코드를 모니터링합니다.
  기계어로 컴파일: 특정 코드가 자주 실행되는 것으로 감지되면, JIT 컴파일러는 그 부분을 네이티브 기계어로 컴파일하여 캐시에 저장합니다.
  최적화된 코드 실행: 이후 해당 코드를 다시 호출하면, JIT은 바이트코드를 인터프리팅하지 않고, 미리 컴파일된 네이티브 코드를 바로 실행합니다. 이로 인해 실행 속도가 빨라집니다.
  동적 최적화: JIT 컴파일러는 실행 중인 코드의 성능을 분석하며, 실행 중에 다양한 최적화를 수행합니다. 필요에 따라 다른 최적화 기법을 적용할 수 있습니다.
  
  JIT 컴파일러의 장점
  빠른 실행 속도: JIT 컴파일러는 자주 실행되는 코드(핫스팟)를 기계어로 변환하기 때문에, 이후의 실행 속도가 매우 빠릅니다.
  동적 최적화: 프로그램이 실행되면서 최적화를 수행할 수 있으므로, 상황에 따라 더 효율적인 코드를 생성할 수 있습니다.
  인터프리터와의 조화: 모든 코드를 처음부터 기계어로 변환하는 것이 아니라, 자주 호출되는 부분만 선택적으로 기계어로 변환하므로, 메모리 사용량과 성능 사이에서 균형을 유지합니다.


public class JITExample {
    public static void main(String[] args) {
        // JIT 컴파일러가 최적화할 수 있는 반복적인 작업
        long startTime = System.nanoTime();
        
        // 반복적으로 메서드를 호출하여 JIT 컴파일러가 최적화하도록 유도
        for (int i = 0; i < 10_000_000; i++) {
            performHeavyCalculation();
        }
        
        long endTime = System.nanoTime();
        System.out.println("Execution Time: " + (endTime - startTime) / 1_000_000 + " ms");
    }

    public static int performHeavyCalculation() {
        int sum = 0;
        for (int i = 0; i < 1_000; i++) {
            sum += Math.sqrt(i); // 무거운 계산 작업
        }
        return sum;
    }
}

동작 설명:
처음 실행: 프로그램을 처음 실행하면 JVM의 인터프리터가 performHeavyCalculation 메서드를 바이트코드로 실행합니다.
반복 실행: 이 메서드는 1,000만 번 호출되므로, JVM은 이 메서드를 핫스팟으로 감지합니다.
JIT 컴파일: JIT 컴파일러는 이 메서드를 네이티브 코드로 컴파일하고 캐시에 저장합니다.
성능 향상: 이후부터는 인터프리팅 없이 네이티브 코드로 빠르게 실행되므로, 실행 시간이 줄어듭니다.

JIT 컴파일러는 이렇게 자주 호출되는 코드를 네이티브 코드로 변환하여 자바 프로그램의 성능을 크게 향상시킵니다.
